/*
一些恶魔抓住了公主（P）并将她关在了地下城的右下角。地下城是由 M x N 个房间组成的二维网格。我们英勇的骑士（K）最初被安置在左上角的房间里，他必须穿过地下城并通过对抗恶魔来拯救公主。

骑士的初始健康点数为一个正整数。如果他的健康点数在某一时刻降至 0 或以下，他会立即死亡。

有些房间由恶魔守卫，因此骑士在进入这些房间时会失去健康点数（若房间里的值为负整数，则表示骑士将损失健康点数）；其他房间要么是空的（房间里的值为 0），要么包含增加骑士健康点数的魔法球（若房间里的值为正整数，则表示骑士将增加健康点数）。

为了尽快到达公主，骑士决定每次只向右或向下移动一步。

 

编写一个函数来计算确保骑士能够拯救到公主所需的最低初始健康点数。

例如，考虑到如下布局的地下城，如果骑士遵循最佳路径 右 -> 右 -> 下 -> 下，则骑士的初始健康点数至少为 7。

-2 (K)	-3	3
-5	-10	1
10	30	-5 (P)
 

说明:

骑士的健康点数没有上限。

任何房间都可能对骑士的健康点数造成威胁，也可能增加骑士的健康点数，包括骑士进入的左上角房间以及公主被监禁的右下角房间。

*/

/*
方法一:动态规划
第一反应动态规划,dp[i][j]数组保存到ij位置需要的生命值
因为走每一步都要维持生命值大于0,所以自底向上,从终点往回走,每次只能向左或者向右
动态转移方程dp[i][j] = Math.max(dp[i + 1][j], dp[i][j + 1]) + dungeon[i][j] 即当前点只可能是之前的右边的点向左走,或下面的向上走得到的
取右和下方点的最大值,并且注意 这里需要判断赋值之后的dp[i][j]是否大于0,如果大于零,说明从这个点走到终点的过程中生命值一定大于0,即只要走到这一步的生命值为1,就一定能走到终点
即这个点之后的路径对结果无影响,换句话说,这个点等于说是新的终点
所以如果赋值后dp[i][j]大于0,就把dp[i][j]赋值为0

初始化状态,dp[row - 1][col - 1] = Math.min(0, dungeon[row - 1][col - 1]); 同理 当dungeon[row - 1][col - 1]大于0时,说明这个点的值对结果无影响,直接归0
初始化最后一行和最后一列,同理每次都要判断是否当前值大于0,大于0则归零

最后输出-dp[0][0] + 1即为结果,+1能保证每一步的剩余生命值至少是1来满足题目要求(不加1即生命值至少为0)

*/

class Solution {
    public int calculateMinimumHP(int[][] dungeon) {
        int row = dungeon.length;
        int col = dungeon[0].length;
        int[][] dp = new int[row][col];
        dp[row - 1][col - 1] = Math.min(0, dungeon[row - 1][col - 1]);
        for(int i = row - 2; i >= 0; i--){
            dp[i][col - 1] = dp[i + 1][col - 1] + dungeon[i][col - 1];
            if(dp[i][col - 1] > 0){
                dp[i][col - 1] = 0;
            }
        }
        for(int j = col - 2; j >= 0; j--){
            dp[row - 1][j] = dp[row - 1][j + 1] + dungeon[row - 1][j];
            if(dp[row - 1][j] > 0){
                dp[row - 1][j] = 0;
            }
        }
        for(int i = dp.length - 2; i >= 0; i--){
            for(int j = dp[0].length - 2; j >= 0; j--){
                dp[i][j] = Math.max(dp[i + 1][j], dp[i][j + 1]) + dungeon[i][j];
                if(dp[i][j] > 0){
                    dp[i][j] = 0;
                }
            }
        }
        return -dp[0][0] + 1;
    }
}
