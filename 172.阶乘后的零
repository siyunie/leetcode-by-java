/*
给定一个整数 n，返回 n! 结果尾数中零的数量。

示例 1:

输入: 3
输出: 0
解释: 3! = 6, 尾数中没有零。
示例 2:

输入: 5
输出: 1
解释: 5! = 120, 尾数中有 1 个零.
说明: 你算法的时间复杂度应为 O(log n) 。

*/

/*
方法一:数学法
第一反应,时间复杂度要求O(log n),考虑二分法,但是二分法明显不适用本题情况
接着想到能得到尾数0的一定是2*5的组合,然后5出现的次数一定比2多,所以就是求阶乘中有多少个5,直接n/5,发现结果不对
因为25等于5*5,125等于5*5*5,一次类推,即要把多个五的情况也加上
所以最后的结果就是 n/5 + n/25 + n/125 + ...,但是这样分母可能溢出,所以写一个循环,每次算完更新, n = n/5 然后每次都加n/5即可
即 n/25 = (n/5)/5 依次类推
假设做k次后n=0结束循环, 5^k = n 即 k = log5(n) 即时间复杂度为O(log n)满足题目要求

*/

class Solution {
    public int trailingZeroes(int n) {
        int count = 0;
        while(n > 0){
            count += n/5;
            n /= 5;
        }
        return count;
    }
}
