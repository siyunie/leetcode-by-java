/*

给定两个大小为 m 和 n 的有序数组 nums1 和 nums2。

请你找出这两个有序数组的中位数，并且要求算法的时间复杂度为 O(log(m + n))。

你可以假设 nums1 和 nums2 不会同时为空。

示例 1:

nums1 = [1, 3]
nums2 = [2]

则中位数是 2.0
示例 2:

nums1 = [1, 2]
nums2 = [3, 4]

则中位数是 (2 + 3)/2 = 2.5

*/

/*
方法一：归并排序
*/

class Solution {
    public double findMedianSortedArrays(int[] nums1, int[] nums2) {
        ArrayList<Integer> list=merge(nums1,nums2);
        int size=list.size();
        if(size==1){
            return (double) list.get(0);
        }else if(size%2==0){
            int mid=size/2;
            return (list.get(mid-1)+list.get(mid))/2.0;
        }else{
            int mid=size/2;
            return (list.get(mid))/1.0;
        }
        
    }
    public static ArrayList<Integer> merge(int[] arr1,int[] arr2){
        int i=0,j=0;
        ArrayList<Integer> list=new ArrayList<>();
        while(i<arr1.length&&j<arr2.length){
            if(arr1[i]<=arr2[j]){
                list.add(arr1[i]);
                i++;
            }else{
                list.add(arr2[j]);
                j++;
            }
        }
        if(i==arr1.length){
            for(;j<arr2.length;j++){
                list.add(arr2[j]);
            }
        }else{
            for(;i<arr1.length;i++){
                list.add(arr1[i]);
            }
        }
        return list;
    }
}


/*
方法二:双指针遍历
时间复杂度不符合要求
一开始考虑合并两个数组,然后直接找中位数,但是这样需要额外的空间,所以直接双指针移动找中位数,注意时间复杂度为O(m + n)不符合题目要求
分两种情况,数组之和的长度为奇数和偶数,为奇数时需要找(len + 1)/2个数即为中位数,因此遍历时需要循环len/2 + 1, 即从0开始,一直到len/2
比如长度为3,指针需要移动一次,因此循环两遍(因为第一次循环未移动指针)
长度之和为偶数时, 需要找len/2 和 len/2 + 1个数,同样需要遍历len/2 + 1次,只不过需要直到前一次遍历的结果,因此用pre保存上一轮的结果,cur保存本轮结果
每次循环开始时,将cur赋给pre即可
因此长度为奇数和偶数的情况循环可以一起写,避免太复杂

循环中,当p1 < m并且满足 p2 >= n即p2已经越界或者 nums[p1] < nums[p2]时移动p1,相反情况移动p2
此处相反情况即为 p1 >= m || (p2 < n && nums1[p1] >= nums[p2])即p1越界或者,在p2不越界的情况下,p2的值小于等于p1

最后判断长度是奇数还是偶数,决定返回值为pre与cur的平均数还是直接返回cur

*/

class Solution {
    public double findMedianSortedArrays(int[] nums1, int[] nums2) {
        int m = nums1.length;
        int n = nums2.length;
        int pre = 0;
        int cur = 0;
        int p1 = 0;
        int p2 = 0;
        for(int i = 0; i <= (m + n)/2; i++){
            pre = cur;
            if(p1 < m && (p2 >= n || nums1[p1] < nums2[p2])){
                cur = nums1[p1++];
            }else{
                cur = nums2[p2++];
            }
        }
        if(((m + n) & 1) == 0){
            return (double)(pre + cur)/2;
        }else{
            return (double)cur;
        }
    }
}
