/*
给定一个整数 n，求以 1 ... n 为节点组成的二叉搜索树有多少种？

示例:

输入: 3
输出: 5
解释:
给定 n = 3, 一共有 5 种不同结构的二叉搜索树:

   1         3     3      2      1
    \       /     /      / \      \
     3     2     1      1   3      2
    /     /       \                 \
   2     1         2                 3

*/

/*
方法一：动态规划
对一个给定序列，可以遍历每一个节点i，将节点的左节点1，2...i-1作为左子树，右节点i+1...n作为右子树构建二叉搜索树
因为每个作为根节点的i节点都不同，所以构成的二叉搜索树自然也不同
dp[n]保存长度为n的序列的所有二叉树个数
F(i,n)表示用i个节点用上述方法构建二叉数的个数
dp[n]=sum(F(i,n)) 即i=1~n的所有F之和
对于边界情况，空树n=0或者只有一个节点n=1,令dp[0]=1，dp[1]=1
对于F(i,n)可以看成左i-1个节点和右n-i个节点的笛卡尔积
而左i-1个节点的所有二叉树个数=dp[i-1]，右n-i个节点的所有二叉树个数=dp[n-i],因为dp对于顺序的数来说构建的二叉搜索树个数与具体的数的值无关，只和长度有关
所以F(i,n)=dp[i-1]*dp[n-i]
所以dp[n]=sum(F(i,n))=sum(dp[i-1]*dp[n-i]),即i=1~n的所有dp[i-1]*dp[n-i]的值之和
*/

class Solution {
    public int numTrees(int n) {
        int[] dp=new int[n+1];
        dp[0]=dp[1]=1;
        for(int i=2;i<=n;i++){
            for(int j=1;j<=i;j++){
                dp[i]+=dp[j-1]*dp[i-j];
            }
        }
        return dp[n];
    }
}
